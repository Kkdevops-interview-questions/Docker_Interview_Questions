# Advanced Docker Interview Questions 
---

## 41. How do you update secrets/configs without restarting containers?

### Explanation:
Docker by itself cannot dynamically update secrets/configs without restarting a container.  
However, there are workarounds depending on the environment.

### Methods:
- Use **Docker Swarm configs**, which are mounted as in-memory files.
- Use **Kubernetes ConfigMaps/Secrets** with volume mounts and automatic reload techniques (sidecars/watchers).
- Use **external secret managers**:
  - AWS Secrets Manager
  - HashiCorp Vault
  - Azure Key Vault  

### Real-World Example:
We integrated the Vault agent injector, which automatically refreshed secrets and updated mounted files without restarting application containers.

---

## 42. How do you prevent container escape vulnerabilities?

### Security Practices:
- Run as non-root users.
- Enable **seccomp**, **AppArmor**, **SELinux** profiles.
- Disable privileged containers (`--privileged=false`).
- Use read-only root filesystems (`--read-only`).
- Use user namespace remapping.
- Avoid host mounts unless necessary.

### Real-World Example:
During a security audit, we hardened all containers with a default seccomp profile to limit kernel syscalls and prevent container breakout attempts.

---

## 43. How do you avoid race conditions during container startup?

### Explanation:
Race conditions occur when a container depends on another service (DB, cache, API) that isn’t ready.

### Solutions:
- Use *init containers* (in orchestrated environments).
- Use health checks to wait until dependencies are ready.
- Use entrypoint scripts with readiness checks:
  ```bash
  until nc -z db 3306; do echo "Waiting for DB..."; sleep 2; done
````

### Real-World Example:

We added a startup script to wait for PostgreSQL readiness before launching our Django app, preventing connection failures.

---

## 44. What are zombie containers and how do you clean them up?

### Explanation:

A zombie container is one that:

* Has stopped unexpectedly,
* Remains in exited state,
* Occupies space and resources.

### Cleanup:

```bash
docker ps -a
docker rm $(docker ps -aq)
docker system prune
```

### Real-World Example:

In our staging servers, build failures created dozens of exited containers.
We automated nightly cleanup using `docker container prune`.

---

## 45. How do you run Docker containers on Kubernetes vs standalone Docker?

### Differences:

* Kubernetes uses a **Container Runtime Interface (CRI)**.
  Docker is no longer the runtime for K8s, but **containerd** is.
* Deployment is managed using manifests (YAML), not `docker run`.
* Scaling, self-healing, and networking are handled by Kubernetes.

### Standalone Docker:

```bash
docker run -d -p 80:80 nginx
```

### Kubernetes:

```yaml
apiVersion: apps/v1
kind: Deployment
spec:
  replicas: 3
  template:
    spec:
      containers:
        - name: nginx
          image: nginx
```

### Real-World Example:

We migrated from standalone Docker to Kubernetes for auto-scaling and rolling deployments.

---

## 46. How do you simulate network failures in containers for testing?

### Tools:

* **Pumba** (Docker chaos testing)
* **Chaos Mesh** (Kubernetes)
* **tc/netem** Linux traffic control tools

### Example:

```bash
pumba netem --interface eth0 delay --time 3000 container_name
```

### Real-World Example:

We used Pumba to test backend retry logic under simulated network latency and packet loss.

---

## 47. What are the common issues with Docker and IPv6?

### Issues:

* IPv6 is disabled by default.
* NAT for IPv6 is not fully supported.
* Some container images are not IPv6-ready.
* Multi-stack routing must be manually configured.

### Real-World Example:

A microservice failed IPv6 compliance checks because the Docker host lacked IPv6 NAT rules, requiring manual daemon.json configuration.

---

## 48. How do you enable IPv6 support for Docker containers?

### Steps:

1. Edit Docker daemon.json:

   ```json
   {
     "ipv6": true,
     "fixed-cidr-v6": "2001:db8:1::/64"
   }
   ```
2. Restart Docker:

   ```bash
   systemctl restart docker
   ```

### Real-World Example:

We enabled IPv6 for compliance with government regulations requiring dual-stack networking.

---

## 49. How do you configure custom DNS for Docker containers?

### Explanation:

You can configure DNS per container or globally.

### Per container:

```bash
docker run --dns=8.8.8.8 --dns=1.1.1.1 nginx
```

### Global configuration:

`/etc/docker/daemon.json`

```json
{
  "dns": ["8.8.8.8", "1.1.1.1"]
}
```

### Real-World Example:

We used corporate internal DNS resolvers for all containers to resolve internal service domains.

---

## 50. How do you restrict container access to certain domains or IPs?

### Methods:

* Use **iptables** or **nftables**.
* Use network-scoped Docker networks.
* Use firewalls on host (UFW).
* Use service mesh policies (Istio, Linkerd).
* Use Cilium or Calico network policies.

### Example:

```bash
iptables -A OUTPUT -p tcp -d blocked.com -j DROP
```

### Real-World Example:

We blocked containers from reaching external public IPs for security compliance purposes.

---

## 51. How do you automate container health and readiness checks?

### Methods:

* Dockerfile `HEALTHCHECK`
* Docker Compose healthcheck
* Kubernetes liveness/readiness probes

### Example:

```dockerfile
HEALTHCHECK CMD curl -f http://localhost:8080/health || exit 1
```

### Real-World Example:

We used health checks in Docker Compose so unhealthy containers were automatically restarted.

---

## 52. How do you roll back a faulty image deployed to production?

### Methods:

* Deploy previous image tag:

  ```bash
  docker run myapp:1.3
  ```
* Use versioned tags instead of `latest`.
* In Kubernetes, use:

  ```bash
  kubectl rollout undo deployment/myapp
  ```

### Real-World Example:

We triggered an immediate rollback after a bad deployment caused high latency.
Since versioned tags were used, rollback took seconds.

---

## 53. What is Docker’s image signing mechanism?

### Explanation:

Docker uses **Docker Content Trust (DCT)** based on Notary and TUF to:

* Sign images
* Verify authenticity
* Prevent tampering

### Command:

```bash
export DOCKER_CONTENT_TRUST=1
```

### Real-World Example:

Our enterprise registry required all images to be signed before deployment.

---

## 54. How do you restrict container image sources to trusted registries?

### Methods:

* Use `--disable-legacy-registry=true`
* Configure allowed registries in Docker daemon.
* Enforce signed images using DCT.
* Use firewall rules to restrict registry access.

### Real-World Example:

We allowed images only from our internal Harbor registry by restricting outbound network access.

---

## 55. What are container runtime interfaces (CRI)? How does Docker interact with them?

### Explanation:

CRI defines how Kubernetes communicates with container runtimes.

### Runtimes:

* containerd
* CRI-O
* runc
* gVisor

Docker is no longer used directly by Kubernetes; instead:

* Docker → containerd → runc

### Real-World Example:

When Kubernetes dropped Docker support, we migrated workloads to containerd.

---

## 56. How does Docker manage shared layers across images?

### Explanation:

Docker stores layers in a shared cache.
If two images use same base layers, Docker stores them once and reuses them.

### Real-World Example:

Two Java services built on `openjdk:17` shared layers, reducing disk usage significantly.

---

## 57. What’s the purpose of squash option while building images?

### Explanation:

`squash` merges all layers into one to:

* Reduce image size
* Avoid leaking intermediate layers
* Improve security

### Example:

```bash
docker build --squash -t myapp .
```

### Real-World Example:

We squashed sensitive build layers that contained temporary credentials.

---

## 58. What are tmpfs mounts and their benefits in Docker?

### Explanation:

`tmpfs` mounts store data **in RAM** instead of disk.

### Benefits:

* Faster reads/writes
* Data wiped on restart
* Good for sensitive or temporary data

### Example:

```bash
docker run --tmpfs /tmp myapp
```

### Real-World Example:

We stored session cache in tmpfs to reduce latency and prevent disk writes.

---

## 59. How can you isolate containers using AppArmor/SELinux profiles?

### Explanation:

These kernel security modules enforce mandatory access controls.

### AppArmor:

```bash
docker run --security-opt apparmor=profile_name myapp
```

### SELinux:

```bash
docker run --security-opt label:type:container_t myapp
```

### Real-World Example:

A security audit required SELinux enforcing mode, which prevented containers from accessing restricted host directories.

---

## 60. How do you perform fine-grained container access controls?

### Methods:

* Linux capabilities (`--cap-drop` / `--cap-add`)
* seccomp profiles
* AppArmor/SELinux
* Network policies
* IAM roles (on cloud)
* API RBAC for registries

### Example:

```bash
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE myapp
```

### Real-World Example:

We dropped all capabilities except what the application needed, reducing attack surface dramatically.

---
